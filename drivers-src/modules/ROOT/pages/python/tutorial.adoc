= Python driver tutorial
:keywords: typedb, typeql, tutorial, python, quickstart, start, sample, example, application, app
:pageTitle: Python driver tutorial
:page-aliases: typedb::tutorials/sample-app.adoc
:summary: A sample application using TypeDB Python driver.

In this tutorial, we'll build a sample application with the Python driver capable of basic interaction with TypeDB:

* Connect to a TypeDB server (Core or Cloud),
* Manage databases, sessions, and transactions,
* Send different types of queries.

Follow the steps below or see the
https://github.com/vaticle/typedb-docs/tree/master/drivers-src/modules/ROOT/partials/tutorials/python/sample.py[full source code,window=_blank].

== Environment setup

To run this sample application, you'll need:

. TypeDB: either a https://cloud.typedb.com/[TypeDB Cloud] deployment or a TypeDB Core server.
For TypeDB Core installation instructions, see the xref:home::install/core.adoc[] page.
. Python and https://pypi.org/project/typedb-driver/[TypeDB Python driver].
For the driver installation instructions, see the xref:drivers::python/overview.adoc[] page.

Use `pip` for the Python driver installation:

[,bash]
----
pip install typedb-driver
----

//#todo Consider adding virtualenv step-by-step guide

== Imported modules

To be able to use the TypeDB Python driver API in the Sample application, use the following import statements:

[,python,indent=0]
----
include::drivers::partial$tutorials/python/sample.py[tag=import]
----

== Default values

We store default values as constants in the source code:

[,python,indent=0]
----
include::drivers::partial$tutorials/python/sample.py[tag=constants]
----

Where `DB_NAME` -- the name of the database to use;
`SERVER_ADDR` -- address of the TypeDB server to connect to;
`TYPEDB_EDITION` -- TypeDB Core or Cloud edition selector;
`CLOUD_USERNAME`/`CLOUD_PASSWORD` -- credentials to connect to TypeDB Cloud.

== Program structure

The main workflow of this sample application includes establishing a connection to TypeDB,
performing a new database setup, and querying.

[,python,indent=0]
----
include::drivers::partial$tutorials/python/sample.py[tag=main]
----

The entire `main()` function code is executed in the context of the network connection
established by the `connect_to_typedb()` function.
The network connection is represented by the `driver` object that is returned by the function.

== TypeDB connection

The `connect_to_typedb()` function takes `edition` and `addr` as mandatory parameters.

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=connection]
----

The `edition` is expected to be a Enum for selecting a TypeDB edition.
Depending on the TypeDB edition selected, this function initializes either a TypeDB Core or TypeDB Cloud connection.
Both require server address, passed in the `addr` parameter.

TypeDB Cloud connection also requires an object of the `TypeDBCredential` class
that is initialized with a username and password.
For our sample application,
we have the default credentials for the `admin` account
provided as default values for the function's optional parameters.

include::partial$tutorials/change-psw.adoc[]

== Database setup

To set up a TypeDB database, we need to <<_creating_a_database,create a database>> on the TypeDB server,
<<_defining_a_schema,define its schema>> and <<_loading_initial_data,load initial data>> into it.
Additionally, we test it to make sure that the setup process is completed successfully.

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=db-setup]
----

[#_creating_a_database]
=== Creating a database

For this sample application we create a new database of the default name `sample_app_db`
in the `try_create_database()` function.
But first, we check whether a database with such a name already exists.

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=create_new_db]
----

If there is no such database, we just create a new database.
But if there is one, we ask user's confirmation on how to proceed.

[NOTE]
====
Avoid deleting an existing database without confirmation from a user to prevent loss of the existing data.
====

By default, the `db_reset` is set to `False` (the default behavior).
In combination with a pre-existing database,
that leads to requesting the user's input on whether to replace the existing database with a new one.

If a user gives confirmation for the replacement, we delete the existing database (with all of its schema and data)
by restarting the `try_create_database()` function with the `db_reset` parameter set to `True`.

If a user doesn't want to delete the existing database,
we proceed further without modification of the existing database.
This will most likely lead to failing the database testing after the setup phase that comes next,
but it prevents user from losing the existing data completely.

[#_defining_a_schema]
=== Defining a schema

After the new database is created,
we use a xref:typeql::schema/define.adoc[Define query] to define a schema for that database.
See the `db_schema_setup()` function:

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=db-schema-setup]
----

The schema for the sample application is stored in the file
https://github.com/vaticle/typedb-docs/tree/master/drivers-src/modules/ROOT/partials/tutorials/iam-schema.tql[iam-schema.tql,window=_blank],
so we read the file first.

.See the full schema
[%collapsible]
====
[,typeql]
----
include::drivers::partial$tutorials/iam-schema.tql[lines=17..]
----
====

We use a session object passed as a parameter to open a transaction.
Then we send the contents of the file as a TypeQL Define query and commit the changes made by the transaction.

[#_loading_initial_data]
=== Loading initial data

With the schema defined, we can load initial data into our database with the xref:typeql::data/insert.adoc[Insert query]
in the `db_dataset_setup()` function:

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=db-dataset-setup]
----

We do it the very same way: read the file
https://github.com/vaticle/typedb-docs/tree/master/drivers-src/modules/ROOT/partials/tutorials/iam-data-single-query.tql[iam-data-single-query.tql,window=_blank]
and send it as a single query, and then commit the changes.

.See the full Insert query
[%collapsible]
====
[,typeql]
----
include::drivers::partial$tutorials/iam-data-single-query.tql[lines=17..]
----
====

=== Testing a database

With the schema defined and data loaded, we test our database to make sure it's ready.
To test the database, we send a query to count the number of users in the database.

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=test-db]
----

== Query examples

After database setup is complete, we proceed with querying our database with different types of queries in the
`queries()` function:

[,python,indent=0]
----
include::drivers::partial$tutorials/python/sample.py[tag=queries]
----

The queries are as follows:

. <<_fetch,Fetch query>> -- to get attribute values in JSONs
. <<_insert,Insert query>> -- to add new data
. <<_get,Get query>> -- to get stateful objects
. <<_get_infer,Get query with inference>> -- to get stateful objects with inference
. <<_update,Update query>> -- to replace data
. <<_delete,Delete query>> -- to delete data

Every query is implemented as a function that includes visualisation of the query response
and returns some meaningful data.

[#_fetch]
=== Fetch query

The main way to retrieve data from a TypeDB database is to use fetching to get values of attributes,
matched by a pattern.

Let's use a xref:typeql::data/fetch.adoc[Fetch query] to fetch names and emails for all users in the database:

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=fetch]
----

We collect response in a list and store it in the `users` variable that is returned by the function.
We iterate through the list and print the results from every JSON in the list.

Since we know that there is only one name and one email every time, we can print only the first element every time.
In general case, there can be multiple attributes of the same type owned,
so we need to consider iterating through all returned values returned for every attribute in every JSON.
That can be done as in the following example:

.Printing JSON for any number of attributes fetched
[,python]
----
for i, JSON in enumerate(users, start=0):
    print(f"User #{i + 1} â€”", end="")
    for result in JSON['u']['full-name']:
        print(f" Full-name:", result['value'], end="")
    for result in JSON['u']['email']:
        print(f" E-mail:", result['value'], end="")
    print()
----

[#_insert]
=== Insert query

Let's insert a new user with `full-name` and `email` attributes to the database.

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=insert]
----

We collect the response of the xref:typeql::data/insert.adoc[Insert query] as a list
and use it to print the inserted data after we commit the transaction.

We iterate through the response, retrieve attribute values and print them for every return result.
Since the Insert query has no `match` clause, the `insert` clause is executed exactly once.
But the Insert query always returns a list of ConceptMap objects, where every ConceptMap represents an inserted result.

[#_get]
=== Get query

Let's retrieve all files available for a user with a `get_files_by_user()` function.
It can be used with or without inference enabled.

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=get]
----

We call the function without enabling the inference and expect it to return no results, as the query pattern
matches only files available for `view_file` action, and there are no such files initially in the database.

The `get_files_by_user()` function checks
that there is only one user matched with the name provided by an input parameter.
It then executes the query and iterates through the list of results to print a value of every matched `path` attribute.

[#_get_infer]
=== Get query with inference

To get query results with inferred data, let's enable the `infer` parameter of the TypeDB transaction options.
We use the same `get_files_by_user()` function, but set the `inference` parameter to `True` when we call it again.
The `add-view-permission` provides us with some inferred results this time.

[#_update]
=== Update query

Let's replace a path for one of the files with a new path.
We can do that by deleting ownership of the old path attribute from the file entity
and assigning it with ownership of the new path attribute with the xref:typeql::data/update.adoc[Update query]:

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=update]
----

We collect the response of the Update query in a list and check the length of the list to determine
the number of times the `delete` and `insert` clauses are executed.
We then commit the changes only if the number meets our expectation.

[#_delete]
=== Delete query

Finally, let's delete the same file we updated the path for.
First, we match the file in a Get (or Fetch) query to check how many files get matched to prevent unplanned deletes.
If the number (and any other relevant parameters) of deletes is as expected,
we proceed with a xref:typeql::data/delete.adoc[Delete query] with the same match clause.

By using the same `write` transaction we employ snapshot isolation
to prevent any other transactions from changing the expected results.
If any other transaction makes a conflicting change before we commit this transaction,
then our transaction fails upon a commit.

[,python]
----
include::drivers::partial$tutorials/python/sample.py[tag=delete]
----

== Learn more

[cols-2]
--
.link:https://github.com/vaticle/typedb-docs/tree/master/drivers-src/modules/ROOT/partials/tutorials/python/sample.py[Source code,window=_blank]
[.clickable]
****
The full source code of this sample application.
****

.xref:drivers::python/api-reference.adoc[]
[.clickable]
****
The full API reference for the TypeDB Python driver.
****
--
