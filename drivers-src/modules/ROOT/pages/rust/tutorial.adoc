= Rust driver tutorial
:keywords: typedb, typeql, tutorial, rust, quickstart, start, sample, example, application, app
:pageTitle: Rust driver tutorial
:summary: A simple example with an application using TypeDB Rust driver.
:tabs-sync-option:

In this tutorial, we'll build a sample application with the Rust driver capable of basic interaction with TypeDB:

* Connect to a TypeDB server (Core or Cloud),
* Manage databases, sessions, and transactions,
* Send different types of queries.

Follow the steps below or see the
https://github.com/vaticle/typedb-docs/tree/master/drivers-src/modules/ROOT/partials/tutorials/rust/src/main.rs[full source code,window=_blank].

== Environment setup

To run this sample application, you'll need:

. TypeDB: either a https://cloud.typedb.com/[TypeDB Cloud] deployment or a TypeDB Core server.
For TypeDB Core installation instructions, see the xref:home::install/core.adoc[] page.
. Rust, cargo, and https://crates.io/crates/typedb-driver[TypeDB Rust driver].
For the driver installation instructions, see the xref:drivers::rust/overview.adoc[] page.

The Sample application below is synchronous for simplicity,
so make sure to add `sync` feature either in the `Cargo.toml` or via the following command:

[,bash]
----
cargo add typedb-driver -F sync
----

//#todo Consider adding virtualenv step-by-step guide
== Imported modules

To be able to use the TypeDB Rust driver API in the Sample application, use the following import statements:

[,rust,indent=0]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=import]
----

== Default values

We store default values as constants in the source code:

[,rust,indent=0]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=constants]
----

Where `DB_NAME` -- the name of the database to use;
`SERVER_ADDR` -- address of the TypeDB server to connect to;
`TYPEDB_EDITION` -- TypeDB Core or Cloud edition selector;
`CLOUD_USERNAME`/`CLOUD_PASSWORD` -- credentials to connect to TypeDB Cloud.

== Program structure

The main workflow of this sample application includes establishing a connection to TypeDB,
database setup, and querying.

[,rust,indent=0]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=main]
----

The entire `main()` function code is executed in the context of the network connection
established by the `connect_to_typedb()` function.
The network connection is represented by the `driver` object that is returned by the function.

== TypeDB connection

The `connect_to_typedb()` function takes `edition` and `addr` as mandatory parameters.

[,rust]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=connection]
----

The `edition` is expected to be a Enum for selecting a TypeDB edition.
Depending on the TypeDB edition selected, this function initializes either a TypeDB Core or TypeDB Cloud connection.
Both require server address, passed in the `addr` parameter.

TypeDB Cloud connection also requires an object of the `TypeDBCredential` class
that is initialized with a username and password.
For our sample application,
we have the default credentials for the `admin` account
provided as default values for the function's optional parameters.

include::partial$tutorials/change-psw.adoc[]

== Database setup

To set up a TypeDB database, we need to <<_creating_a_database,create a database>> on the TypeDB server,
<<_defining_a_schema,define its schema>> and <<_loading_initial_data,load initial data>> into it.
Additionally, we test it to make sure that the setup process is completed successfully.

[,rust]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=db-setup]
----

[#_creating_a_database]
=== Creating a database

For this sample application we create a new database of the default name `sample_app_db`
in the `try_create_database()` function.
But first, we check whether a database with such a name already exists.

[,rust]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=create_new_db]
----

If there is no such database, we just create a new database.
But if there is one, we ask user's confirmation on how to proceed.

[NOTE]
====
Avoid deleting an existing database without confirmation from a user to prevent loss of the existing data.
====

By default, the `db_reset` is set to `false`.
In combination with a pre-existing database,
that leads to requesting the user's input on whether to replace the existing database with a new one.

If a user gives confirmation for the replacement, we delete the existing database (with all of its schema and data)
by restarting the `try_create_database()` function with the `db_reset` parameter set to `true`.

If a user doesn't want to delete the existing database,
we proceed further without modification of the existing database.
This will most likely lead to failing the database testing after the setup phase that comes next,
but it prevents user from losing the existing data completely.

[#_defining_a_schema]
=== Defining a schema

After the new database is created,
we use a xref:typeql::schema/define.adoc[Define query] to define a schema for that database.
See the `db_schema_setup()` function:

[,rust]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=db-schema-setup]
----

The schema for the sample application is stored in the file
https://github.com/vaticle/typedb-docs/tree/master/drivers-src/modules/ROOT/partials/tutorials/iam-schema.tql[iam-schema.tql,window=_blank],
so we read the file first.

.See the full schema
[%collapsible]
====
[,typeql]
----
include::drivers::partial$tutorials/iam-schema.tql[lines=17..]
----
====

We use a session object passed as a parameter to open a transaction.
Then we send the contents of the file as a TypeQL Define query and commit the changes made by the transaction.

[#_loading_initial_data]
=== Loading initial data

With the schema defined, we can load initial data into our database with the xref:typeql::data/insert.adoc[Insert query]
in the `db_dataset_setup()` function:

[,rust]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=db-dataset-setup]
----

We do it the very same way: read the file
https://github.com/vaticle/typedb-docs/tree/master/drivers-src/modules/ROOT/partials/tutorials/iam-data-single-query.tql[iam-data-single-query.tql,window=_blank]
and send it as a single query, and then commit the changes.

.See the full Insert query
[%collapsible]
====
[,typeql]
----
include::drivers::partial$tutorials/iam-data-single-query.tql[lines=17..]
----
====

=== Testing a database

With the schema defined and data loaded, we test our database to make sure it's ready.
To test the database, we send a query to count the number of users in the database.

[,rust]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=test-db]
----

== Query examples

After database setup is complete, we proceed with querying our database with different types of queries in the
`queries()` function:

[,rust,indent=0]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=queries]
----

The queries are as follows:

. <<_fetch,Fetch query>> -- to get attribute values as JSON
. <<_insert,Insert query>> -- to add new data
. <<_get,Get query>> -- to get stateful objects
. <<_get_infer,Get query with inference>> -- to get stateful objects with inference
. <<_update,Update query>> -- to replace data
. <<_delete,Delete query>> -- to delete data

Every query is implemented as a function that includes visualisation of the query response
and returns some response.

[#_fetch]
=== Fetch query

The main way to retrieve data from a TypeDB database is to use fetching to get values of attributes,
matched by a pattern.

Let's use a xref:typeql::data/fetch.adoc[Fetch query] to fetch names and emails for all users in the database:

[,rust]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=fetch]
----

We get the response as a stream of results, containing JSON.
We create a `result` variable to store the results and iterate through stream to print and store JSONs.

//#todo Add printing Names and E-mail from a JSON, add multiple names/e-mails implementation

[#_insert]
=== Insert query

Let's insert a new user with `full-name` and `email` attributes to the database.

[,rust]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=insert]
----

The Insert query returns a stream of ConceptMaps: one for every `insert` clause execution.
We iterate through the stream to print and store the inserted data.
Then we commit the changes and return the stored results.

Since the Insert query has no `match` clause, the `insert` clause is executed exactly once.
But the Insert query always returns a list of ConceptMap objects, where every ConceptMap represents an inserted result.

[#_get]
=== Get query

Let's retrieve all files available for a user with a `get_files_by_user()` function.
It can be used with or without inference enabled.

[,rust]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=get]
----

We call the function with the inference disabled (`false`) and expect it to return no results, as the query pattern
matches only files available for `view_file` action, and there are no such files initially in the database.

The `get_files_by_user()` function checks
that there is only one user matched with the name provided by an input parameter.
It then executes the query to find the files, collect the results, and
iterates through them to print a value of every matched `path` attribute.

[NOTE]
====
For bigger numbers of results it might be faster to iterate through a stream,
rather than collect and store the results first.
====

[#_get_infer]
=== Get query with inference

To get query results with inferred data, let's enable the `infer` parameter of the TypeDB transaction options.
We use the same `get_files_by_user()` function, but set the `inference` parameter to `true` when we call it again.
The `add-view-permission` rule provides us with some inferred results this time.

[#_update]
=== Update query

Let's replace a path for one of the files with a new path.
We can do that by deleting ownership of the old path attribute from the file entity
and assigning it with ownership of the new path attribute with the xref:typeql::data/update.adoc[Update query]:

[,rust]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=update]
----

We collect the response of the Update query and check the length of it to determine
the number of times the `delete` and `insert` clauses are executed.
We then commit the changes only if the number meets our expectation.

[#_delete]
=== Delete query

Finally, let's delete the same file we updated the path for.
First, we match the file in a Get (or Fetch) query to check how many files get matched to prevent unplanned deletes.
If the number (or any other relevant parameters) of matched results is as expected,
we proceed with a xref:typeql::data/delete.adoc[Delete query] with the same match clause.

By using the same `write` transaction we employ snapshot isolation
to prevent any other transactions from changing the expected results.
If any other transaction makes a conflicting change before we commit this transaction,
then our transaction fails upon a commit.

[,rust]
----
include::drivers::partial$tutorials/rust/src/main.rs[tag=delete]
----

== Learn more

[cols-2]
--
.link:https://github.com/vaticle/typedb-docs/tree/master/drivers-src/modules/ROOT/partials/tutorials/rust/src/main.rs[Source code,window=_blank]
[.clickable]
****
The full source code of this sample application.
****

.xref:drivers::rust/api-reference.adoc[]
[.clickable]
****
The full API reference for the TypeDB Rust driver.
****
--
