= Lesson 9.3: Avoiding data redundancies

== Identifying redundancies

In the previous lesson, we created a first iteration of a data model for book data. In this lesson, we'll see how we can eliminate data redundancies generated by the model.

.Data table
[%collapsible]
====
[%header,format=csv]
|===
include::attachment$books.csv[]
|===
====

.Lesson 9.2 schema
[%collapsible]
====
[,typeql]
----
define
book sub entity,
    owns isbn-13,
    owns isbn-10,
    owns title,
    owns format,
    owns page-count,
    owns genre,
    owns price,
    owns stock,
    plays contribution:work,
    plays publishing:published;
author sub entity,
    owns name,
    plays contribution:contributor;
editor sub entity,
    owns name,
    plays contribution:contributor;
illustrator sub entity,
    owns name,
    plays contribution:contributor;
other-contributor sub entity,
    owns name,
    plays contribution:contributor;
publisher sub entity,
    owns name,
    plays publishing:publisher;
city sub entity,
    owns name,
    plays publishing:location;
state sub entity,
    owns name,
    plays publishing:location;
country sub entity,
    owns name,
    plays publishing:location;
contribution sub relation,
    relates contributor,
    relates work;
publishing sub relation,
    relates publisher,
    relates published,
    relates location,
    owns year;
isbn-13 sub attribute, value string;
isbn-10 sub attribute, value string;
title sub attribute, value string;
format sub attribute, value string;
page-count sub attribute, value long;
genre sub attribute, value string;
price sub attribute, value double;
stock sub attribute, value long;
name sub attribute, value string;
year sub attribute, value long;
----
====

Currently, when recording the location in which a book was published, we must record the city, state, and country.

[,typeql]
----
match
$book isa book, has isbn-13 "9780575104419";
$publisher isa publisher, has name "Hachette Book Group";
$city isa city, has name "New York City";
$state isa state, has name "New York";
$country isa country, has name "United States";
insert
(
    publisher: $publisher,
    published: $book,
    location: $city,
    location: $state,
    location: $country
) isa publishing, has year 2010;
----

However, there is a https://en.wikipedia.org/wiki/Functional_dependency[functional dependency] of state on city, as knowing the city (by identity, not just by name) in which a book is published is sufficient to determine the state in which it was published. Similarly, there is a functional dependency of country on state, and thus country on city, as functional dependencies are https://en.wikipedia.org/wiki/Transitive_relation[transitive]. Simply recording the city should be sufficient, as the state and country should then be inferrable. In fact, we saw this inference performed explicitly in xref:learn::3-reading-data/3.3-fetching-inferred-data.adoc[Lesson 3.3].

This highlights a problem with the data model. The entity types `state` and `country` have functional dependencies on the entity type `city`. Meanwhile, `city` has a functional dependency on `book` via the `publishing` relation type, in which they both play roles. Thus, `state` and `country` both have transitive function dependencies on `book`. However, `state` and `country` also have direct functional dependencies on `book` via `publishing`. This means that `state` and `country` have *duplicate dependencies* on `book`. When dependencies are duplicated, this creates redundancy in the data model, which can lead to data inconsistencies.

== Eliminating redundancies

In order to prevent these inconsistencies, we must refactor the model in such a way that ensures there are no duplicate dependencies. In a relational database, this process is known as https://en.wikipedia.org/wiki/Lossless_join_decomposition[lossless join decomposition]. To do this, we must first explicitly record the dependencies of `country` on `state` and of `state` on `city`, which are currently not captured by the data model. Then, we must remove the dependencies of `country` and `state` on `book`. The end result will be:

* `city` depends on `book`.
* `state` depends on `city`.
* `country` depends on `state`.

`city`, `state`, and `country` will then each have only a single functional dependency on `book`, preventing data redundancies and inconsistencies. To be able to record the new dependencies, we'll introduce a new `locating` relation type.

[,typeql]
----
define
locating sub relation,
    relates located,
    relates location;
city plays locating:located;
state plays locating:location,
    plays locating:located;
country plays locating:location;
----

Next, we'll record the locations of cities using the new type.

[,typeql]
----
match
$city isa city, has name "New York City";
$state isa state, has name "New York";
$country isa country, has name "United States";
insert
(located: $city, location: $state) isa locating;
(located: $state, location: $country) isa locating;
----

Now, whenever we record the location a book is published, we only need to store the city.

[,typeql]
----
match
$book isa book, has isbn-13 "9780575104419";
$publisher isa publisher, has name "Hachette Book Group";
$city isa city, has name "New York City";
insert
(publisher: $publisher, published: $book, location: $city) isa publishing,
    has year 2010;
----

If we wish to know the state or the country it was published, we can easily query this information via the `location` relations.
