= Lesson 9.2: Writing networks of rules
// = Lesson 10.2: Writing networks of rules

== Rule chaining

Much like views in a relational database, which can be generated from other views, rules in TypeDB can leverage data generated by other rules. In fact, we've already seen an example of this in the previous lesson with the following rules.

[,typeql]
----
rule review-verified-by-purchase:
    when {
        ($review, $product) isa rating;
        ($order, $product) isa order-line;
        ($user, $review) isa action-execution, has timestamp $review-time;
        ($user, $order) isa action-execution, has timestamp $order-time;
        $review-time > $order-time;
    } then {
        $review has verified true;
    };
----

[,typeql]
----
rule review-unverified:
    when {
        $review isa review;
        not { $review has verified true; };
    } then {
        $review has verified false;
    };
----

Here, the second rule, `review-unverified`, has the following statement in its condition.

[,typeql]
----
$review has verified true;
----

But this statement is also the conclusion of the first rule! This allows the rules to form a *chain* of logic. TypeDB resolves rules by https://en.wikipedia.org/wiki/Backward_chaining[backward chaining], which we'll now explore an example of. Let's say we issue the following query, which lists the IDs of unverified reviews.

[,typeql]
----
match
$review isa review, has verified false;
fetch
$review: id;
----

When executing this query, TypeDB divides the pattern into individual constraints and attempts to search for each of them. Where there are dependencies between constraints, as described in xref:learn::7-understanding-query-patterns/7.6-solution-set-semantics.adoc[Lesson 7.6], these constraints are resolved in the most efficient order as determined by the query planner. At some point, TypeDB will attempt to resolve the following constraint.

[,typeql]
----
$review has verified false;
----

In addition to searching for data that meets this constraint on disk, TypeDB will also check rules in the schema to see if any of their conclusions match the constraint. In doing so, it will identify that the rule `review-unverified` concludes this constraint. As https://en.wikipedia.org/wiki/Modus_ponens[the condition of a rule implies its conclusion], TypeDB searches for data that matches this rule's condition, as any match will satisfy the target constraint by the logic of the rule.

TypeDB treats the condition of this rule in the same way as the query pattern. First, it divides the condition into individual constraints. Then it attempts to search for each of them in some planned order, both on disk and in rule conclusions. As a result, TypeDB will eventually attempt to resolve the negated constraint.

[,typeql]
----
$review has verified true;
----

The rule `review-verified-by-purchase` is identified as being able to satisfy it, and this process repeats itself, with TypeDB now searching for data matching _its_ condition. This is the basic sequential mechanism of backward chaining. The inference engine works backward from the target constraint in the query, triggering rules sequentially along the way to form a chain. If the rule at the head of the chain is successfully resolved, then all the rules back up the chain are also resolved, and the target constraint is satisfied.

This pair of rules is just one example of rules that can form a chain, and rule chaining is a powerful method for encoding complex domain logic. As long as the condition of one rule contains the conclusion of another, the rules can chain into each other. There is no limit to the permitted depth of a rule chain, and when combined with rule branching, this can lead to complex emergent behaviour that cannot be captured with any single rule.

== Rule branching

=== Mutually exclusive branches

We encountered the following rule in xref:learn::10-using-inference/10.1-rules-as-views.adoc[Lesson 9.1], which is designed to dynamically generate line totals for orders as they are queried.
// We encountered the following rule in xref:learn::10-using-inference/10.1-rules-as-views.adoc[Lesson 10.1], which is designed to dynamically generate line totals for orders as they are queried.

[,typeql]
----
rule order-line-total:
    when {
        $book isa book, has price $retail-price;
        $line ($book) isa order-line, has quantity $quantity;
        ?line-total = $quantity * $retail-price;
    } then {
        $line has price ?line-total;
    };
----

However, this rule does not take into account any discounts due to sales. Let's go about solving this problem by replacing it with two new rules. The first rule will check that there are no applicable discounts, then use the retail price to calculate the line total.


[,typeql]
----
rule order-line-total-retail-price:
    when {
        ($order) isa action-execution, has timestamp $order-time;
        $line ($order, $item) isa order-line;
        not {
            ($promotion, $item) isa promotion-inclusion;
            $promotion has start-timestamp <= $order-time,
                has end-timestamp >= $order-time;
        };
        $item has price $retail-price;
        $line has quantity $quantity;
        ?line-total = $quantity * $retail-price;
    } then {
        $line has price ?line-total;
    };
----

The second rule will check that there is an applicable discount, also check that there is no better applicable discount, then use the best discounted price to calculate the line total.

[,typeql]
----
rule order-line-total-discounted-price:
    when {
        ($order) isa action-execution, has timestamp $order-time;
        $line ($order, $item) isa order-line;
        ($best-promotion, $item) isa promotion-inclusion, has discount $best-discount;
        $best-promotion has start-timestamp <= $order-time,
            has end-timestamp >= $order-time;
        not {
            ($other-promotion, $item) isa promotion-inclusion, has discount > $best-discount;
            $other-promotion has start-timestamp <= $order-time,
                has end-timestamp >= $order-time;
        };
        $item has price $retail-price;
        ?discounted-price = round(100 * $retail-price * (1 - $best-discount)) / 100;
        $line has quantity $quantity;
        ?line-total = $quantity * ?discounted-price;
    } then {
        $line has price ?line-total;
    };
----

Here we have used two mutually exclusive *branches* of logic. Because both of the rules have the same conclusion, they represent two alternative sets of conditions. In fact, it would be possible to combine them into a single rule using a disjunction, but such a complex rule wouldn't be easy to work with. This way, we can clearly divide the two alternatives.

In this case, it's important to make the two conditions mutually exclusive, as we wouldn't want to generate more than one line total per order line. If we examine the patterns, we can see that this has been achieved with a negation. The first rule includes the following constraints.

[,typeql]
----
($order) isa action-execution, has timestamp $order-time;
$line ($order, $item) isa order-line;
not {
    ($promotion, $item) isa promotion-inclusion;
    $promotion has start-timestamp <= $order-time,
        has end-timestamp >= $order-time;
};
----

Meanwhile, the second rule includes the following ones.

[,typeql]
----
($order) isa action-execution, has timestamp $order-time;
$line ($order, $item) isa order-line;
($best-promotion, $item) isa promotion-inclusion;
$best-promotion has start-timestamp <= $order-time,
    has end-timestamp >= $order-time;
----

If we carefully compare them, we see that an instance of `$line` could never possibly meet both sets of constraints. This ensures that the two rules have mutually exclusive conditions, so more than one line total could never be generated.

=== Overlapping branches

In some cases, it is not necessary to ensure that rules are mutually exclusive. Consider the following two rules. The first one checks for pairs of books that have the same author, where a user has liked (ordered or highly rated) one of the books, but has not interacted with (ordered or rated) the other. It then recommends the new book to the user with a `recommendation` relation.

[,typeql]
----
rule book-recommendation-by-author:
    when {
        $user isa user;
        $liked-book isa book;
        {
            ($user, $order) isa action-execution;
            ($order, $liked-book) isa order-line;
        } or {
            ($user, $review) isa action-execution;
            ($review, $liked-book) isa rating;
            $review has score >= 7;
        };
        $new-book isa book;
        not { {
            ($user, $order) isa action-execution;
            ($order, $new-book) isa order-line;
        } or {
            ($user, $review) isa action-execution;
            ($review, $new-book) isa rating;
        }; };
        ($liked-book, $shared-author) isa authoring;
        ($new-book, $shared-author) isa authoring;
    } then {
        (recommended: $new-book, recipient: $user) isa recommendation;
    };
----

The second one works in the same way, except it checks for pairs of books with the same genre rather than author (except for "fiction" or "nonfiction"). It also generates a `recommendation` relation.

[,typeql]
----
rule book-recommendation-by-genre:
    when {
        $user isa user;
        $liked-book isa book;
        {
            ($user, $order) isa action-execution;
            ($order, $liked-book) isa order-line;
        } or {
            ($user, $review) isa action-execution;
            ($review, $liked-book) isa rating;
            $review has score >= 7;
        };
        $new-book isa book;
        not { {
            ($user, $order) isa action-execution;
            ($order, $new-book) isa order-line;
        } or {
            ($user, $review) isa action-execution;
            ($review, $new-book) isa rating;
        }; };
        $liked-book has genre $shared-genre;
        $new-book has genre $shared-genre;
        not { {
            $shared-genre == "fiction";
        } or {
            $shared-genre == "nonfiction";
        }; };
    } then {
        (recommended: $new-book, recipient: $user) isa recommendation;
    };
----

These two rules represent branches of logic, except they are not mutually exclusive. Two books could have the same author and genre (in fact, this is very often the case), and neither rule employs a negation of the other's constraints. However, only one `recommendation` relation can be generated between each book and user, even if both rules are triggered.

As we learned in xref:learn::10-using-inference/10.1-rules-as-views.adoc[Lesson 9.1], rule inference will not generate data that already exists. Crucially, that includes data that exists in the scope of the transaction because it was generated by another rule. With the previous pair of rules for calculating line totals, the retail and discounted totals would be different so TypeDB would insert both. In this case, the conclusions are completely identical, so duplication would not occur. We can take advantage of this property of rule inference to add as many rules as we want that create recommendation relations in this way, all based on different criteria.
