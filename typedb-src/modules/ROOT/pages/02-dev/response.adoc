= Response interpretation
:Summary: TypeDB query response interpretation.
:keywords: typeql, query, response, result, answer, concept
:longTailKeywords: typeql response, concept map, typeql variables
:pageTitle: Response interpretation

TypeDB can return a response in different formats, depending on a type of query. The response will be interpreted by a
TypeDB Client being used. TypeDB Client provides classes and methods for different response types respectively. Please
see the table below for mapping of response format to a type of query that has been sent.

[cols="^1,^4,^4"]
|===
| *#* | *Query type* | *Response format*

| 1
| Get query
| Stream/Iterator of *ConceptMap*

| 2
| Get query with aggregation
| *Future* of *Numeric*

| 3
| Get query with grouping
| Stream/Iterator of *ConceptMapGroup*

| 4
| Get query with grouping and aggregation
| Stream/Iterator of *NumericGroup*

| 5
| Insert query
| Stream/Iterator of *ConceptMap*

| 6
| Delete query
| *Future* (of empty response)

| 7
| Update (match-delete-insert) query
| Stream/Iterator of *ConceptMap*

| 8
| Define
| *Future* (of empty response)

| 9
| Undefine
| *Future* (of empty response)

| 10
| Explain
| Stream/Iterator of *Explanation*
|===

== Expected results

See the table above for an overview of response formats. For more details see the <<_response_formats,Response formats>>
section below.

=== Get query

The ordinary xref:02-dev/read.adoc#_get_query[get query] (without xref:02-dev/read.adoc#_aggregation[aggregation] or
xref:02-dev/read.adoc#_group[grouping]) returns a stream/iterator of a ConceptMap objects.

Every iteration returns result as a <<_conceptmap,ConceptMap>> object.

=== Get query with aggregation

The get query with *aggregation* can only return a singular value (aggregated result). Hence, it returns a Future
object of Numeric.

Use <<_future,Future>> object's `get()` method to wait and retrieve the <<_numeric,Numeric>> object when it's ready.

=== Get query with grouping

The get query with *grouping* returns a stream/iterator of ConceptMapGroup objects.

Every iteration should return result as a <<_conceptmapgroup,ConceptMapGroup>> object.

Use ConceptMapGroup object to retrieve <<_conceptmap,ConceptMap>>.

=== Get query with grouping and aggregation

The get query with *grouping* and *aggregation* returns a stream/iterator of a NumericGroup objects.

Every iteration should return result as a <<_numericgroup,NumericGroup>> object.

Use NumericGroup object to retrieve <<_numeric,Numeric>>.

[#_insert_query]
=== Insert query

An insert query returns a stream/iterator of a ConceptMap objects.

Every iteration should return result as a <<_conceptmap,ConceptMap>> object.

[#_delete_query]
=== Delete query

Delete query can only return a Future object of a void (empty response).

We can't retrieve any useful data from the Future object for delete query.

=== Update (match-delete-insert) query

Similar to an <<_insert_query,insert>> query.

=== Define query

Similar to a <<_delete_query,delete>> query.

=== Undefine query

Similar to a <<_delete_query,delete>> query.

=== Explain

Explain query returns a stream/iterator of an Explanation objects.

For more information on inference explanation please see the xref:02-dev/infer.adoc[Inferring data] page.

[#_response_formats]
== Response formats

xref:clients::studio.adoc[TypeDB Studio] and xref:clients::console.adoc[TypeDB Console] process the
responses automatically to present the results (in GUI and CLI respectively) to the user.

For xref:clients::clients.adoc#_typedb_drivers[TypeDB Drivers]: the specific methods/calls used to interpret the
response depend on the TypeDB Driver used.

The following is a very basic description of objects used to interpret the results from the TypeDB query response.
For more information please see the xref:02-dev/api.adoc[API & Drivers] page and documentation for the
xref:clients::java/java-overview.adoc[Java],
xref:clients::python/python-overview.adoc[Python], and
xref:clients::node-js/node-js-overview.adoc[Node.js] TypeDB Drivers respectively.

[#_conceptmap]
=== ConceptMap

ConceptMap is a special object, made for mapping of variables from a query to concepts in a database. Its methods
provide a way to interact with the concepts.

Usually represents a single solution/answer from a stream of answers for a TypeDB query.

[#_conceptmapgroup]
=== ConceptMapGroup

It's a container for a <<_conceptmap,ConceptMap>> object with an owner.

[#_concept]
=== Concept

Object to represent a type or an instance of a type (data) from a database.

There are separate methods for every built-in type and for instances of every built-in type.

[#_numeric]
=== Numeric

Numeric object represents a numeric value.

[#_numericgroup]
=== NumericGroup

NumericGroup object has not only a Numeric object but also an owner.

[#_future]
=== Future

Future object represents an asynchronous query result to be able to get the value later, when query execution completes.

=== Explanation

Explanation is a special object returned as a response to an explain query.
These are used to explain xref:02-dev/infer.adoc[data inference]. To perform an
xref:02-dev/infer.adoc#_explain_query[explain query] use `explainables` and `explainable` objects.

== Number of answers

If the query type can return *multiple* results (e.g.,a get query) then the result of such query type is a
*stream/iterator* to iterate through all the results. Even if the actual query of such type returns one result or no
results at all -- it returns a stream/iterator with one or zero iterations respectively.

Query types that can return only a single answer or a void (an empty response) are executed fully asynchronous on the
server. To wait for a query to finish execution, and return its result if there is one, use the `get()` method of the
*Future* object returned by the query.

== Best practice

=== Asynchronous queries

Invoking a TypeQL query sends it to a TypeDB server, where it will be completed in the background. Local processing
can take place while waiting for responses to be received. Take advantage of these asynchronous queries to mask network
round-trip costs and increases throughput.

For example, if we are performing 10 get queries in a transaction, it's best to send them all to the server before
iterating over any of their answers.
